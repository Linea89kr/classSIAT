<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    function funcA(a, b, c) {
        console.log(a, b, c)
        console.dir(this)
    }

    const b = {
        d: 1,
        e: 2,
        f: 3,
        funcA(a, b, c) {
            console.log(`---------mathodA---------`)
            console.log(a, b, c)
        }
    }
    b.funcA(1, 2, 3)
    // funcA.call(b, 1, 2, 3); // 1 2 3
    // funcA(1, 2, 3) // A에서 실행하면 window가 나옴.
    /*
    b라는 객체의 인자값들을 차례로 넣어줌.
    다시 말하자면,
    b.function(1,2,3)과 같음.

    다른 곳의 함수를 마치 내가 가진 메서드 인 양 호출함.

    call 이나 apply나 bind를 선언했을 경우에는
    this의 타겟이 window가 아니라 해당 객체로 바뀜.
    this를 여기저기 박아뒀다 call apply bind를 쓸 경우 에러가 남.
    this를 다른 클래스에다 끌어 쓸 경우 this가 가리키는 대상이 달라지기 때문.

    */


</script>

<button id="btn1">버튼</button>
<script>
    function eventA() {
        this
    }
    document.getElementById(`btn1`).addEventListener(`click`, function (e) {
        e.target;
    })

    // document.getElementById(`btn1`).addEventListener(`click`, function () {
    //     eventA(this)
    // })

    /*
    this는 상대
    */
</script>
<script>
    // 외부에서 함수를 불러들이거나, e.target으로 고정된 좌표를 박은 뒤 그것으로 this를 대체.
    // this는 메소드를 호출할 때에는 상대적으로 불러들이는 것이 되어서 그닥 좋은 케이스는 아님.
    // 하지만 this도 써야할 때가 있긴 함.
    // 그게 언제냐면 

    let a = {
        a1: 123,
        b1() {
            console.log(this.a1)
        }
        // 내부에 있는 걸 바로 접근하기 위해 메서드를 쓰는데,
        // 객체 내부에 있는 프로퍼티를 바로 가져와서 써야하는 경우가 있다면 그때 this를 씀.
    }
</script>


</html>