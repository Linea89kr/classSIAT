<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="div1">
        <custom-div>버트으으은</custom-div>
    </div>
    <template id="temp1">
        <style>
            h1 {
                color: red;
            }
        </style>
        <h1>hello!</h1>
        <p>world!</p>
    </template>
</body>
<script>
    // 클래스

    /*
    * 기존의 생성자 방식을 대체하기 위해 만들어진 기능
    * 클래스는 기존의 객체지향 프로그래밍 방식에서 사용하고 있는 클래스의 기능을 본딴 그대로 사용 가능하도록 만들어졌다.
    * 기존의 생성자방식에서 나왔던 복잡성과 가독성적인 부분을 상당부분 해결하였으며 현재 es6 표준으로 사용되고 있다.
    * 형식: class [클래스명] (프로퍼티, 메서드 ...)
    * 클래스 내에 기존의 생성자 방식과 동일하게 프로퍼티와 메서드를 선언할 수 있다.
    *   
    * 
    * 프로퍼티
    * 클래스 내에서 선언하는 속성
    * 객체가 생성될 때 해당 속성을 받아 사용한다.
    * 속성을 선언하는 방식은 두가지 방식이 있으며,
    * * 1. 클래스 내에 속성을 선언하는 방식,
    * * 2. constructor 내에 선언하는 방식,
    * * 2가지가 있으며,  보통 1번보다 2번을 더 많이 사용한다.
    * 클래스 내에 속성을 선언할 경우 앞의 변수에 this 혹은 var/let/const 없이 변수명만
    * 선언하여 사용 가능하며 constructor 내에 선언하는 경우 반드시 변수 앞에는 this를 붙여 줘야 한다.
    * 프로퍼티에는 일반적인 프리미티브 타입 및 레퍼런스 타입 전부 선언이 가능하다.
    * 
    * 메서드
    * 
    * 클래스 내에서 선언되는 기능 단위
    * 보통 메서드와 클래스의 prototype 내에 저장이 되며 생성된 객체에서 사용하고자 하는 기술을 선언할 때 사용할 수 있다.
    * 형식: [메서드명]() {... 들어갈 로직}
    * 메서드 앞에 function 같은 접두어는 들어가지 않으며 마치 객체 내에서 선언되는 기능과 동일하게 선언하면 된다.
    * 기존의 생성자 방식에서는 prototype.메서드명!을 통해 선언할 수 있었으나 클래스는 자동으로 해당 메서드 기능들을 prototype내에 저장한다. 하지만 이전에 사용했던 생성자 방식으로 선언이 불가능한 것은 아니다.
    * 
    * constructor
    * 
    * 클래스에서 사용하는 생성자 메서드
    * 객체 생성시에 딱 한번만 호출되어지는 메서드이며 constructor는 하나만 선언이 가능하다.
    * constructor는 해당 객체 생성시 객체에 들어가는 프로퍼티의 초기화를 위해 사용되어 생성자 함수에서 함수 파라미터로 받은 내용들을 프로퍼티에 저장하여 사용하는 것과 같은 기능이다.
    * 보통 일반 프로퍼티는 constructor 내에 선언되어지는 경우가 많은데 이 경우 반드시 프로퍼티 앞에는 this, 를 붙여 사용해야 한다.
    * 만약 constructor를 선언하지 않을 경우 prototype 내에 존재하는 default constructor가 실행된다.
    */




    // const div1 = document.getElementById(`div1`)
    // div1.append(document.getElementById(`temp1`).content.cloneNode(true))

    class CustomDiv extends HTMLElement {
        connectedCallback() {
            this.attachShadow({ mode: `open` });
            this.shadowRoot.append(temp1.content.cloneNode(`true`));
        }
    }
    customElements.define(`custom-div`, CustomDiv);
</script>

</html>